<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>給可愛的妹妹</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: "Microsoft JhengHei", "PingFang TC", sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            pointer-events: none;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 1.5s ease-in-out; /* 文字出現也加快 */
        }
        h1 {
            font-size: 3.5rem;
            margin: 10px 0;
            text-shadow: 0 0 15px rgba(255,105,180,0.9);
            letter-spacing: 8px;
        }
        h2 {
            font-size: 2.2rem;
            margin: 10px 0;
            font-weight: 300;
        }
        h5 {
            font-size: 1.2rem;
            margin-top: 30px;
            color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>


</div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const uiContainer = document.getElementById('ui');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

let particles = [];
let rockets = [];

class Particle {
    constructor(x, y, color, velocity, sizeMultiplier) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.velocity = velocity;
        this.alpha = 1;
        this.friction = 0.95; // 降低摩擦力，讓擴散更快速
        this.gravity = 0.12;  // 增加重力，讓粒子掉落更自然快速
        this.size = (Math.random() * 2 + 1) * sizeMultiplier;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.restore();
    }

    update() {
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        this.velocity.y += this.gravity;
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.alpha -= 0.015; // 消失速度加快，畫面比較不會亂
    }
}

class Rocket {
    constructor(x, targetY, color, triggerText = false, customSize = 1.0) {
        this.x = x;
        this.y = canvas.height;
        this.targetY = targetY;
        this.color = color;
        // 顯著提升上升速度 (從原本的 6-10 提升到 12-18)
        const speed = Math.random() * 6 + 12;
        this.velocity = { x: (Math.random() - 0.5) * 2, y: -speed };
        this.exploded = false;
        this.triggerText = triggerText;
        this.sizeMultiplier = customSize;
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.velocity.y += 0.1; // 上升過程中的重力感更強

        if (this.velocity.y >= 0 || this.y <= this.targetY) {
            this.exploded = true;
            this.explode();
        }
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
    }

    explode() {
        const particleCount = Math.floor(200 * this.sizeMultiplier);
        const angleStep = (Math.PI * 2) / particleCount;
        for (let i = 0; i < particleCount; i++) {
            // 炸開的初始速度提升
            const speed = (Math.random() * 12 + 5) * this.sizeMultiplier;
            particles.push(new Particle(this.x, this.y, this.color, {
                x: Math.cos(angleStep * i) * speed,
                y: Math.sin(angleStep * i) * speed
            }, this.sizeMultiplier));
        }
        
        if (this.triggerText) {
            setTimeout(() => {
                uiContainer.style.opacity = 1;
            }, 300);
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // 尾跡更短，顯得更俐落
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    rockets.forEach((rocket, index) => {
        rocket.update();
        rocket.draw();
        if (rocket.exploded) rockets.splice(index, 1);
    });

    particles.forEach((particle, index) => {
        if (particle.alpha > 0) {
            particle.update();
            particle.draw();
        } else {
            particles.splice(index, 1);
        }
    });
}

animate();

function launchInteractive(clientX, clientY) {
    const count = Math.floor(Math.random() * 3) + 1;
    for (let i = 0; i < count; i++) {
        setTimeout(() => {
            const color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            const size = Math.random() * 1.0 + 0.6;
            const targetX = clientX + (Math.random() - 0.5) * 150;
            rockets.push(new Rocket(targetX, clientY, color, false, size));
        }, Math.random() * 200); // 縮短連發之間的間隔
    }
}

// 啟動開場
setTimeout(() => {
    const centerX = canvas.width / 2;
    const centerY = canvas.height * 0.3;
    
    // 1. 主大煙火
    rockets.push(new Rocket(centerX, centerY, `hsl(${Math.random() * 360}, 100%, 80%)`, true, 2.2));

    // 2. 旁邊伴隨的小煙火 (數量稍微增加，更熱鬧)
    for (let i = 0; i < 4; i++) {
        setTimeout(() => {
            const offsetX = (Math.random() - 0.5) * canvas.width * 0.7;
            const sideColor = `hsl(${Math.random() * 360}, 100%, 65%)`;
            rockets.push(new Rocket(centerX + offsetX, centerY + (Math.random() - 0.5) * 200, sideColor, false, 0.7));
        }, Math.random() * 400); 
    }
}, 500); // 開場等待縮短

canvas.addEventListener('mousedown', (e) => launchInteractive(e.clientX, e.clientY));
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    launchInteractive(e.touches[0].clientX, e.touches[0].clientY);
});

</script>
</body>

</html>
